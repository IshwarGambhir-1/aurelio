package com.yash.luxevite.categoryservice.serviceimpl;


import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.yash.luxevite.categoryservice.dto.CategoryRequest;
import com.yash.luxevite.categoryservice.dto.CategoryResponse;
import com.yash.luxevite.categoryservice.dto.CategoryTreeResponse;
import com.yash.luxevite.categoryservice.exception.CategoryNotFoundException;
import com.yash.luxevite.categoryservice.exception.CategoryServiceException;
import com.yash.luxevite.categoryservice.model.Category;
import com.yash.luxevite.categoryservice.model.CategoryGender;
import com.yash.luxevite.categoryservice.model.CategoryStatus;
import com.yash.luxevite.categoryservice.repository.CategoryRepository;
import com.yash.luxevite.categoryservice.service.CategoryService;

import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of CategoryService interface
 * Handles category management operations with proper error handling and logging
 */
@Service
@Slf4j
@Transactional
public class CategoryServiceImpl implements CategoryService {

    private final CategoryRepository categoryRepository;

    @Autowired
    public CategoryServiceImpl(CategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    @Override
    public CategoryResponse createCategory(CategoryRequest categoryRequest) {
        log.info("Creating new category: {}", categoryRequest.getName());
        
        try {
            // Validate if category with same name and gender already exists
            if (categoryRepository.existsByNameAndGender(categoryRequest.getName(), categoryRequest.getGender())) {
                log.warn("Category with name '{}' and gender '{}' already exists", 
                        categoryRequest.getName(), categoryRequest.getGender());
                throw new CategoryServiceException(
                    String.format("Category with name '%s' and gender '%s' already exists", 
                                categoryRequest.getName(), categoryRequest.getGender())
                );
            }

            // Validate slug uniqueness
            if (categoryRequest.getSlug() != null && 
                categoryRepository.existsBySlug(categoryRequest.getSlug())) {
                log.warn("Category with slug '{}' already exists", categoryRequest.getSlug());
                throw new CategoryServiceException("Category with slug '" + categoryRequest.getSlug() + "' already exists");
            }

            // Convert DTO to Entity
            Category category = mapToEntity(categoryRequest);
            
            // Set parent category if provided
            if (categoryRequest.getParentCategoryId() != null) {
                Category parentCategory = categoryRepository.findById(categoryRequest.getParentCategoryId())
                        .orElseThrow(() -> new CategoryNotFoundException(
                            "Parent category not found with ID: " + categoryRequest.getParentCategoryId()));
                category.setParentCategory(parentCategory);
            }

            // Generate slug if not provided
            if (category.getSlug() == null || category.getSlug().trim().isEmpty()) {
                category.setSlug(generateSlug(category.getName()));
            }

            // Save category
            Category savedCategory = categoryRepository.save(category);
            log.info("Category created successfully with ID: {}", savedCategory.getId());
            
            return CategoryResponse.fromEntity(savedCategory);
            
        } catch (DataAccessException e) {
            log.error("Database error while creating category: {}", categoryRequest.getName(), e);
            throw new CategoryServiceException("Failed to create category due to database error", e);
        } catch (Exception e) {
            log.error("Unexpected error while creating category: {}", categoryRequest.getName(), e);
            throw new CategoryServiceException("Failed to create category", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryResponse getCategoryById(Long id) {
        log.debug("Fetching category by ID: {}", id);
        
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("Category not found with ID: {}", id);
                    return new CategoryNotFoundException("Category not found with ID: " + id);
                });
        
        log.debug("Category found: {}", category.getName());
        return CategoryResponse.fromEntity(category);
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryResponse getCategoryBySlug(String slug) {
        log.debug("Fetching category by slug: {}", slug);
        
        Category category = categoryRepository.findBySlug(slug)
                .orElseThrow(() -> {
                    log.warn("Category not found with slug: {}", slug);
                    return new CategoryNotFoundException("Category not found with slug: " + slug);
                });
        
        return CategoryResponse.fromEntity(category);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CategoryResponse> getAllCategories(Pageable pageable) {
        log.debug("Fetching all categories with pagination: page {}, size {}", 
                 pageable.getPageNumber(), pageable.getPageSize());
        
        try {
            Page<Category> categoriesPage = categoryRepository.findAll(pageable);
            log.info("Retrieved {} categories out of {} total", 
                    categoriesPage.getNumberOfElements(), categoriesPage.getTotalElements());
            
            return categoriesPage.map(CategoryResponse::fromEntity);
            
        } catch (DataAccessException e) {
            log.error("Database error while fetching all categories", e);
            throw new CategoryServiceException("Failed to fetch categories due to database error", e);
        }
    }

    @Override
    public CategoryResponse updateCategory(Long id, CategoryRequest categoryRequest) {
        log.info("Updating category with ID: {}", id);
        
        try {
            Category existingCategory = categoryRepository.findById(id)
                    .orElseThrow(() -> new CategoryNotFoundException("Category not found with ID: " + id));

            // Check for name and gender conflict (excluding current category)
            if (!existingCategory.getName().equals(categoryRequest.getName()) ||
                !existingCategory.getGender().equals(categoryRequest.getGender())) {
                
                if (categoryRepository.existsByNameAndGender(categoryRequest.getName(), categoryRequest.getGender())) {
                    throw new CategoryServiceException(
                        String.format("Category with name '%s' and gender '%s' already exists", 
                                    categoryRequest.getName(), categoryRequest.getGender()));
                }
            }

            // Check for slug conflict (excluding current category)
            if (categoryRequest.getSlug() != null && 
                !categoryRequest.getSlug().equals(existingCategory.getSlug()) &&
                categoryRepository.existsBySlug(categoryRequest.getSlug())) {
                throw new CategoryServiceException("Category with slug '" + categoryRequest.getSlug() + "' already exists");
            }

            // Update category fields
            updateCategoryFromRequest(existingCategory, categoryRequest);
            
            // Update parent category if changed
            if (categoryRequest.getParentCategoryId() != null && 
                (existingCategory.getParentCategory() == null || 
                 !existingCategory.getParentCategory().getId().equals(categoryRequest.getParentCategoryId()))) {
                
                Category newParent = categoryRepository.findById(categoryRequest.getParentCategoryId())
                        .orElseThrow(() -> new CategoryNotFoundException(
                            "Parent category not found with ID: " + categoryRequest.getParentCategoryId()));
                
                // Prevent circular reference
                if (isCircularReference(existingCategory, newParent)) {
                    throw new CategoryServiceException("Circular reference detected in category hierarchy");
                }
                
                existingCategory.setParentCategory(newParent);
            } else if (categoryRequest.getParentCategoryId() == null) {
                existingCategory.setParentCategory(null);
            }

            Category updatedCategory = categoryRepository.save(existingCategory);
            log.info("Category updated successfully with ID: {}", id);
            
            return CategoryResponse.fromEntity(updatedCategory);
            
        } catch (DataAccessException e) {
            log.error("Database error while updating category with ID: {}", id, e);
            throw new CategoryServiceException("Failed to update category due to database error", e);
        }
    }

    @Override
    public void deleteCategory(Long id) {
        log.info("Deleting category with ID: {}", id);
        
        try {
            Category category = categoryRepository.findById(id)
                    .orElseThrow(() -> new CategoryNotFoundException("Category not found with ID: " + id));

            // Check if category has subcategories
            if (category.hasSubCategories()) {
                throw new CategoryServiceException("Cannot delete category with subcategories. Please delete subcategories first.");
            }

            // Check if category has products (you would integrate with product service)
            // if (category.getProducts() != null && !category.getProducts().isEmpty()) {
            //     throw new CategoryServiceException("Cannot delete category with associated products.");
            // }

            categoryRepository.deleteById(id);
            log.info("Category deleted successfully with ID: {}", id);
            
        } catch (DataAccessException e) {
            log.error("Database error while deleting category with ID: {}", id, e);
            throw new CategoryServiceException("Failed to delete category due to database error", e);
        }
    }

    @Override
    public CategoryResponse updateCategoryStatus(Long id, CategoryStatus status) {
        log.info("Updating status for category ID: {} to: {}", id, status);
        
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new CategoryNotFoundException("Category not found with ID: " + id));

        category.setStatus(status);
        Category updatedCategory = categoryRepository.save(category);
        log.info("Status updated successfully for category ID: {}", id);
        
        return CategoryResponse.fromEntity(updatedCategory);
    }

    @Override
    public CategoryResponse addSubCategory(Long parentId, CategoryRequest subCategoryRequest) {
        log.info("Adding subcategory to parent category ID: {}", parentId);
        
        Category parentCategory = categoryRepository.findById(parentId)
                .orElseThrow(() -> new CategoryNotFoundException("Parent category not found with ID: " + parentId));

        // Validate subcategory name uniqueness under this parent
        if (categoryRepository.existsByNameAndGender(subCategoryRequest.getName(), subCategoryRequest.getGender())) {
            throw new CategoryServiceException(
                String.format("Category with name '%s' and gender '%s' already exists", 
                            subCategoryRequest.getName(), subCategoryRequest.getGender()));
        }

        Category subCategory = mapToEntity(subCategoryRequest);
        subCategory.setParentCategory(parentCategory);

        // Generate slug if not provided
        if (subCategory.getSlug() == null || subCategory.getSlug().trim().isEmpty()) {
            subCategory.setSlug(generateSlug(subCategory.getName()));
        }

        Category savedSubCategory = categoryRepository.save(subCategory);
        log.info("Subcategory added successfully with ID: {}", savedSubCategory.getId());
        
        return CategoryResponse.fromEntity(savedSubCategory);
    }

    @Override
    public CategoryResponse updateCategoryOrder(Long id, Integer displayOrder) {
        log.info("Updating display order for category ID: {} to: {}", id, displayOrder);
        
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new CategoryNotFoundException("Category not found with ID: " + id));

        category.setDisplayOrder(displayOrder);
        Category updatedCategory = categoryRepository.save(category);
        log.info("Display order updated successfully for category ID: {}", id);
        
        return CategoryResponse.fromEntity(updatedCategory);
    }

    // Filtering and query operations
    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getCategoriesByGender(CategoryGender gender) {
        log.debug("Fetching categories by gender: {}", gender);
        return categoryRepository.findByGender(gender).stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getCategoriesByGenderAndStatus(CategoryGender gender, CategoryStatus status) {
        log.debug("Fetching categories by gender: {} and status: {}", gender, status);
        return categoryRepository.findByGenderAndStatus(gender, status).stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getFeaturedCategories() {
        log.debug("Fetching featured categories");
        return categoryRepository.findByIsFeaturedTrue().stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getFeaturedCategoriesByGender(CategoryGender gender) {
        log.debug("Fetching featured categories by gender: {}", gender);
        return categoryRepository.findByGenderAndIsFeaturedTrue(gender).stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getRootCategories() {
        log.debug("Fetching root categories");
        return categoryRepository.findByParentCategoryIsNull().stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getRootCategoriesByGender(CategoryGender gender) {
        log.debug("Fetching root categories by gender: {}", gender);
        return categoryRepository.findByParentCategoryIsNullAndGender(gender).stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getSubCategories(Long parentId) {
        log.debug("Fetching subcategories for parent ID: {}", parentId);
        return categoryRepository.findByParentCategoryId(parentId).stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryTreeResponse> getCategoryTree() {
        log.debug("Building complete category tree");
        
        List<Category> rootCategories = categoryRepository.findByParentCategoryIsNull();
        return rootCategories.stream()
                .map(CategoryTreeResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryTreeResponse> getCategoryTreeByGender(CategoryGender gender) {
        log.debug("Building category tree for gender: {}", gender);
        
        List<Category> rootCategories = categoryRepository.findByParentCategoryIsNullAndGender(gender);
        return rootCategories.stream()
                .map(CategoryTreeResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CategoryResponse> searchCategories(String query, Pageable pageable) {
        log.debug("Searching categories with query: {}", query);
        return categoryRepository.searchCategories(query, pageable)
                .map(CategoryResponse::fromEntity);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsByNameAndGender(String name, CategoryGender gender) {
        return categoryRepository.existsByNameAndGender(name, gender);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsBySlug(String slug) {
        return categoryRepository.existsBySlug(slug);
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getCategoriesWithProductCount() {
        log.debug("Fetching categories with product count");
        // This would integrate with product service
        // For now, return regular categories
        return categoryRepository.findAll().stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<CategoryResponse> getCategoriesByGenderWithProductCount(CategoryGender gender) {
        log.debug("Fetching categories by gender with product count: {}", gender);
        // This would integrate with product service
        // For now, return regular categories by gender
        return categoryRepository.findByGender(gender).stream()
                .map(CategoryResponse::fromEntity)
                .collect(Collectors.toList());
    }

    // Helper methods
    private Category mapToEntity(CategoryRequest request) {
        Category category = new Category();
        category.setName(request.getName());
        category.setDescription(request.getDescription());
        category.setImageUrl(request.getImageUrl());
        category.setBannerImageUrl(request.getBannerImageUrl());
        category.setGender(request.getGender());
        category.setStatus(request.getStatus());
        category.setDisplayOrder(request.getDisplayOrder());
        category.setIsFeatured(request.getIsFeatured());
        category.setMetaTitle(request.getMetaTitle());
        category.setMetaDescription(request.getMetaDescription());
        category.setMetaKeywords(request.getMetaKeywords());
        category.setSlug(request.getSlug());
        return category;
    }

    private void updateCategoryFromRequest(Category category, CategoryRequest request) {
        category.setName(request.getName());
        category.setDescription(request.getDescription());
        category.setImageUrl(request.getImageUrl());
        category.setBannerImageUrl(request.getBannerImageUrl());
        category.setGender(request.getGender());
        category.setStatus(request.getStatus());
        category.setDisplayOrder(request.getDisplayOrder());
        category.setIsFeatured(request.getIsFeatured());
        category.setMetaTitle(request.getMetaTitle());
        category.setMetaDescription(request.getMetaDescription());
        category.setMetaKeywords(request.getMetaKeywords());
        
        if (request.getSlug() != null) {
            category.setSlug(request.getSlug());
        }
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-")
                .trim();
    }

    private boolean isCircularReference(Category category, Category potentialParent) {
        Category current = potentialParent;
        while (current != null) {
            if (current.getId().equals(category.getId())) {
                return true;
            }
            current = current.getParentCategory();
        }
        return false;
    }
}